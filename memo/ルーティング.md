## ルーティング

フロントコントローラを使うことで、処理を簡単に組み込むことができる。
反面、URLと書くコントローラの対応を制御する必要が出てくる。

そのために「URLからPATH_INFOを抜き出す処理をRequestクラスに実装した。

取得したPath_INFOからコントローラとアクションを特定する処理をルーティングという。

```
  https://domain.com/user/edit?page=2
  この場合のPATH_INFOは　「user/edit」

```

例えば、抜き出した/user/editというPATH_INFOをUserコントローラのeditアクションに対応させるなど、ルールを定義する。

##  ルーティング方法

URLとコントローラを対応付ける
これは、アプリケーションごとに定義する必要がある。

シンプルに連想配列でルーティング定義を行えるようにする。

```

array(
  '/'
    =>array('controller' => 'home', 'action' => 'index'),
  '/user/edit'
    =>array('controller' => 'user', 'action' => 'edit'),
);

```

キー部分にPATH_INFO部分を指定し、値にはコントローラとアクションを記述。
こうすることで、キーの値と現在のPATH_INFOを比較してマッチした場合は、値を返してくれる。


> 書くコントローラはクラスとして定義しているが、URLに大文字が入るのは見栄えが良くない。
> ルーティング上では小文字で定義し、実際にコントローラクラスを読み込む際に大文字に変換して扱う



## 動的ルーティング
`/user?id=1`というURLを`user/1`として扱うなど、GETパラメータとして指定していた部分をPATH_INFOに含めたい場合もある。

ルーティングはPHPで制御できるため、そういった仕組みを盛り込むことも可能。

「コロン(:)で始まる文字列を指定すると、動的なパラメータとして扱えるようにする。

```

array(
  '/user/:id'
    =>array('controller' => 'user', 'action' => 'show')
);

```

`:id`の部分が動的なパラメータになる。
これを正規表現で変換してマッチングさせ、コントローラ側でidの値を取得できるようにする。
